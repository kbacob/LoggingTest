Logging lib + test

Ковырясь со своим веб-сервером, полез в мультипоточность, начал оптимизировать, всё нахрен поломал и наткнулся на проблемы с блокировками при протоколировании событий. Тот код, что был написан ранее, оказался не способен как адеватно работать в мультипоточной среде, так и справляться с тысячами запросов на протоколирование в секунду. Конечно, скорее всего, мне такая производительность не понадобится, но ведь хочется попробовать...

Идея была следующая - делаем массив строк, одна строка - одно событие. Фоновая задача по мере возможности этот массив обрабатывает, скидывая данные на терминал, консоль debug или в файл. Или всё сразу. После обработки массив обрезается. Таким образом, если даже не успеваем всё показывать или записывать, ничего не теряется. Потом массив строк превратился в List<Tuple<DateTime, RecordType, string>>

Библиотечка умеет не особенно много:
- вывод сообщений на терминал, в Debug-консоль dotnet/VisualStudio, в файл
- категоризация (Verbose, Warning, Error и т.п.) ну и фильтрация на этой основе
- выбор формата префикса, указывающего время события
- выбор формата префикса, указывающего категорию события
- раскраска категорий событий при выводе сообщений на терминал
- сортировка событий по времени (оказалось нужно, когда в протокол спамит сразу сотня потоков)
- небольшой возможный тюнинг

Ну а по сути всё просто:

var Logging logging = new Logging("path/to/file") // достаточно и этого, всё что ниже - кастомизация
{
    level = Logging.Level.Verbose,
    receiver = Logging.Receiver.File | Logging.Receiver.Console,
    timeFormat = Logging.TimeFormat.ShortLocalized,
    intBufferLength = 200,
    intFlushSleepInterval = 1000,
    boolColorisedConsoleOutput = true,
    boolSortByTime = false
};
Logging.Debug("Ops");
Logging.Error("I do it again");
Logging.Dispose(); // оказалось, что нада. Финализатор ~ автоматом не вызвается, эта хрень тоже.

Поскольку это не совсем библиотека а, скорее, проверка концепции, и класс Logging и тестовая программулька лежат в Program.cs Обновлять, наверное, не буду, потому что скопирую в основную библиотеку ik

Если код корявый - извиняйте, только учусь.
